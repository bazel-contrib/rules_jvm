# JUnit 5 Test Runner

This package contains a JUnit5 test runner. The design goals for this are:

* To not leak any classes on to the test's classpath
  * This implies only using classes from the JRE or JUnit5 base classes
* To provide test logs...
  * ... that can be consumed by the Bazel IJ plugin
  * ... that are as similar to those generated by Maven and Gradle as possible

The requirements about test logs are to support running tests via the IJ plugin,
and to allow test results to be ingested by existing systems that process the 
JUnit4 XML output. For the sake of argument, we shall be attempting to use the
[JUnit XML XSD][xsd] provided by the JUnit team.

For reference, the JUnit XSD suggests that there be a top-level `testsuites` 
tag. This can contain any number of `testsuite` tags. Each of these 
`testsuite` tags may only contain any number of nested `testcase` tags. The 
model does not allow nesting of `testsuite` tags within `testsuite` tags. 

## Test log formats

JUnit5 has a number of different ways of running and not running tests, so a 
quick review of how each of the existing test frameworks. For each of these 
we'll consider the various following combinations:

* "Simple": A regular test case, using no special features
* "Suite": A test suite, created using the `@Suite` annotation and containing 
  two test classes
* "Dynamic" A dynamic test using the `@TestFactory` annotation
* "Parameterised" A parameterised test case
* "Pathological" A parameterised test case where the test method is disabled 
  using a custom 
  annotation

This last example is a pathological example test, combining dynamic tests 
with the custom features of JUnit5.

### Gradle

The JUnit XSD suggests that there's a `properties` tag that can be populated 
by the system properties present when the test was running. In all cases, 
Gradle does not populate this with any values.

#### Simple

Generates a top-level `testsuite` named after the class, containing a single 
`testcase` per method. The `testcase` method's `name` attribute is the name 
of the test as if a method call (eg. `something()`)

#### Suite

Generates a separate test output file per class included in the suite, and 
these are formatted in the same way as the "Simple" case. There is no file 
generated for the class annotated with the `Suite` annotation.

#### Dynamic

Creates a test file with a top-level `testsuite` with a `name` attribute 
matching the test name. There is no entry for the generator method, but each 
generated test case creates a single `testcase` entry. Each `testcase` has a 
`name` attribute populated with the display name of the generated test case.

#### Parameterised

Similar to the "dynamic" example, gradle creates a single file for the whole 
test, with a top-level `testsuite` with a `name` attribute matching the test 
class's name. The method generating the inputs is ignored, but each 
generated test is represented as a `testcase` with a `name` attribute 
matching the display name of the test (eg. `[1] alpha`)

#### Pathological

Gradle creates a single file with a `testsuite` named after the test class. 
No matter how many generated test cases should be generated, only a single 
`testcase` entry is generated. This is named after the method signature of 
the test method (eg. `example(String)`). This single `testcase` contains a 
self-closed `skipped` tag.

### Maven

The SureFire test plugin was used to generate the test reports. This is one 
of the most commonly used maven plugins for testing.

In all cases, the top-level `testsuite` tag has a nested `properties` tag 
which contains all the values of `System.getProperties()`

#### Simple

Creates a single file, with a top-level `testsuite` tag, named after the 
test class. This contains a nested `testcase` for each test method within 
the class. The `name` attribute of the `testcase` is named after the test 
method, without any signature information (eg. `something`)

#### Suite

Maven will generate a file for the class tagged with `Suite`. This will 
contain a single `testsuite` tag, named after the class. There will be no 
nested `testcase` tags. Instead, each class referenced by the suite will 
have its own test log file written. The format of each of these will be the 
same as if the test were run on its own.

#### Dynamic

Creates a single test file, with a top-level `testsuite` tag named after the 
test class. This contains one nested `testcase` tag per generated dynamic 
test case. Each `testcase` has the same name, which is that of the 
generating method, which makes distinguishing them a tricky thing to do.

The generating method does not otherwise appear in the generated XML file.

#### Parameterised

Just as with Gradle, this is similar to the format generated by the 
"dynamic" test, with a top-level `testsuite` tag named after the test class, 
and each generated `testcase` being nested within that. Each `testcase` has 
a `name` attribute that matches the automatically generated test name (that 
is `testMethod(String)[1]`) rather than the display name of the test. 

#### Pathological

Maven generates a single file with a top-level `testsuite` tag named after 
the test class. This contains a single `testcase` with a `name` attribute 
matching the method signature (`example(String)`) no matter how many test 
would have been generated. The single `testcase` contains a nested `skipped` 
tag, which contains the reason why the test was skipped, as generated by 
JUnit itself.

### JUnit5's legacy XML output listener

In all cases, the generated top-level `testsuite` tags have a nested 
`properties` tag, with the contents of `System.getProperties()` being present.

For each test, two files are generated: one for the default "jupiter" runner,
and one for the "suite" runner. The most relevant output is described below 
(in most cases the "jupiter" file)

#### Simple

A top-level `testsuite` tag named `JUnit Jupiter`, with a nested `testcase` 
per test method invoked. The `testcase` has a `name` attribute which is the 
method name with signature information (eg. `example()`.

#### Suite

This is the only time when the generated "suite" file contains the useful 
information. 

The top-level `testsuite` tag is named `JUnit Platform Suite`, and contains 
a `testcase` entry for each test run in any of the classes listed in the 
suite. The `name` attribute for each of these `testcase` tags is the method 
name of the test, with type information (eg. `example()`), but each has the 
`classname` attribute set properly so it's possible to distinguish the test 
cases from one another.

#### Dynamic

Generates a top-level `testsuite` named `JUnit Jupiter`, containing a 
`testcase` for each generated test case. These are named after the 
generating method, but with a number appended (eg. `factory()[1]`)

#### Parameterised

This is exactly the same as the output generated by Maven, with the twist 
that the top-level `testsuite` is named `JUnit Jupiter`. The individual 
`testcase` tag have a `name` attribute matching the automatically generated 
test name (eg. `testMethod{String)[1]`).

#### Pathological

Creates a single test class with a top-level `testsuite` tag named `JUnit
Jupiter`. This contains a single `testcase` tag with a `name` attribute 
matching the method signature of the ignored test case (eg. `example(String)
`) no matter how many tests would have been generated. The single `testcase` 
contains a nested `skipped` tag, containing the reason for the test being 
skipped.

### Bazel's JUnit4 runner

Obviously, not every test type supported by JUnit5 can be represented by 
JUnit4, but for those that can....

In all cases, Bazel generates a single file per test target. The generated 
`testsuite` tags each have an empty `properties` tag. Bazel is also the only 
test runner that generates a top-level `testsuites` tag for each file.

#### Simple

Below the `testsuites` tag is a single `testsuite` tag. This is named after 
the test class name. Nested below this is a `testcase` for each test method. 
The `name` attribute is the name of the test method without type information 
(eg. `example`)

#### Suite

Skipped

#### Dynamic

Skipped

#### Parameterised

Parameterised tests work slightly differently in JUnit 4 than they do in 
JUnit5. In JUnit4, each parameter is passed to the constructor of the test 
class, meaning that each test class must store that value on a field for it 
to be accessible to test methods.

Below the `testsuites` tag is a `testsuite` tag for the test class itself. 
This is basically empty.

For each generated test case, there is a `testsuite` entry, named after the 
order in which the suite was generated (eg. `[0]` or `[1]`). Within each of 
those `testsuite` entries is a `testcase` per method in the test class, 
where each `testcase` has a `name` attribute that is a combination of the 
test method name without signature information and the run number (eg. 
`someTest[1]`)

#### Pathological

Skipped

## Desired behaviour

The output generated by this runner has to meet the two requirements listed 
at the start of the doc. This means that we shall always issue a top-level 
`testsuites` tag. The XSD makes it clear that this can only contain 
`testsuite` tags, and these can only contain `testcase` tags. 

When executing tests, JUnit5 prepares a test plan. This contains all the 
statically defined tests that have been discovered by each test engine that 
is available to it. These are arranged in a hierarchy, with "test roots" 
being the actual engine being used. These test roots are used by the legacy 
XML listener to provide the suite name, which is why they bear no relation 
to a class name at all. 

Neither Gradle nor Maven expose the root containers, so it's appropriate 
that we don't do that either.

The reason that the legacy XML listener is outputting top-level test suites 
with names like `JUnit Platform Suite` is that these are the names of the 
engines being used. That is, rather than looking at the _nearest_ container, 
each `testcase` is nested in the ancestor container that does not have a 
parent. 

In no case do we want the "engine" suite appearing in our outputs.

#### Simple

A `testsuite` named after the class, with a `testcase` for each test method.

#### Suite

An optional `testsuite` for the class annotated with the suite itself, which 
should be empty, and then a `testsuite` for each class that the test suite 
runs, each of which should have a `testcase` per test method.

The reason for this structure is that it's possible for the class annotated 
with `Suite` to also contain test methods, and we want to report those if 
present. In the ideal world, we might want to nest the `testsuite` tags. 
However, by not doing so we firstly conform to the XSD of expected outputs, 
and, secondly, we have an XML file that more closely mirrors what would be 
output if the individual test were run. 

#### Dynamic

It seems like both Maven and Gradle agree on this: a `testsuite` named after 
the containing class, and a `testcase` per generated method.

#### Pathological

The other runners broadly agree: a `testsuite` named after the class, and a 
single `testcase` per generated test.

## Desired output

The approach we've chosen to take is to execute all the tests, and once a 
test root is done, find the tests without any children. We render these as 
`testcase` instances. Within JUnit5, each test has a `TestIdentifier`, and 
these each have a parent. We find the parent `TestIdentifier` for each 
identified `testcase` and use _that_ as the `testsuite` that contains the 
test. In the cases we've investigated, the outputs we see are roughly 
equivalent to what we see coming out of both Maven and Gradle.

[xsd]: https://github.com/junit-team/junit5/blob/main/platform-tests/src/test/resources/jenkins-junit.xsd