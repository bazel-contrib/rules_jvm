load("@bazel_gazelle//:def.bzl", "gazelle_binary", "gazelle_generation_test")
load(":gazelle_build_mode.bzl", "gazelle_embedded_javaparser")

# It's important not to add any BUILD.bazel files in any subdirectory of this one. If you find tests failing which look like files are missing, it's likely a BUILD.bazel file has accidentally been added.

# We don't want gazelle to run on this directory's children, as having BUILD.bazel files would stop the test_data globs from reaching into the directories.
# We do, however, want to include this BUILD.bazel file in Gazelle's knowledge, otherwise gazelle will view this directory as not being a package and will include testdata/** as a `data` glob in the parent's test target.
# This causes problems when running Bazel with `--incompatible_disallow_empty_glob`.
# gazelle:exclude *

gazelle_binary(
    name = "gazelle",
    languages = [
        "@bazel_gazelle//language/proto:go_default_library",
        "//java/gazelle",
    ],
    visibility = ["//visibility:private"],
)

gazelle_embedded_javaparser(
    name = "gazelle_embedded_javaparser",
    gazelle_binary = ":gazelle",
)

# Each of these tests has the following structure:
# * A WORKSPACE file.
# * Optionally an `expectedStdErr.txt`, an `expectedStdOut.txt`, and an `expectedExitCode.txt`. If a test fails, it will offer you a command line to run to generate them.
# * Some input files.
# * A BUILD.out file for each expected generated BUILD.bazel file.
# * A paired BUILD.in file (generally empty, unless the test requires pre-existing BUILD files, such as for directive comments).
#
# Some tests also contain fully filled out WORKSPACE and/or maven_install.json files. These were generated by doing roughly:
# `cd subdir && for f in $(fd BUILD.out); do mv ${f} $(dirname ${f})/BUILD.bazel; done && bazel run @unpinned_maven//:pin && rm -rf bazel-* && for f in $(fd BUILD.bazel); do mv ${f} $(dirname ${f})/BUILD.out; done`
#
# Other tests just use `gazelle:resolve` comments to resolve maven artifacts, or just don't (and get warnings to stderr as a result.

SKIPPED_ON_WINDOWS = [
    "lib_with_invalid_label_in_runtime_deps",
    "lib_with_runtime_deps_and_map_kind",
    "maven_with_collision_and_resolve",
    "module_granularity_with_sources",
]

[
    gazelle_generation_test(
        name = file[0:-len("/WORKSPACE")],
        env = {
            "GAZELLE_JAVA_LOG_CALLER": "false",
            "GAZELLE_JAVA_LOG_FORMAT": "json",
            "GAZELLE_JAVA_LOG_TIMESTAMP": "false",
        },
        gazelle_binary = ":gazelle",
        gazelle_timeout_seconds = 60,
        tags = ["skip-windows"] if file[0:-len("/WORKSPACE")] in SKIPPED_ON_WINDOWS else [],
        test_data = glob(
            include = [file[0:-len("/WORKSPACE")] + "/**"],
        ),
    )
    for file in glob(["**/WORKSPACE"])
]

# Run an arbitrary subset of embedded tests to validate that it works
[
    gazelle_generation_test(
        name = file[0:-len("/WORKSPACE")] + "e",  # Windows path limits means that we need to keep these names short. Regrettably, "_embedded" is too long of a suffix, and so is "_e"
        env = {
            "GAZELLE_JAVA_LOG_CALLER": "false",
            "GAZELLE_JAVA_LOG_FORMAT": "json",
            "GAZELLE_JAVA_LOG_TIMESTAMP": "false",
        },
        gazelle_binary = ":gazelle_embedded_javaparser",
        gazelle_timeout_seconds = 60,
        tags = ["skip-windows"],
        test_data = glob(
            include = [
                file + "/**",
            ],
        ),
    )
    for file in [
        "annotation_processor",
        "java_export_targets",
        "kt_split_package",
        "maven_with_collision_and_resolve",
        "proto",
    ]
]
