package javaconfig

import (
	"fmt"
	"io/fs"
	"os"
	"path"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/bazel-contrib/rules_jvm/java/gazelle/private/sorted_set"
	"github.com/bazel-contrib/rules_jvm/java/gazelle/private/types"
	bzl "github.com/bazelbuild/buildtools/build"
)

const (
	// JavaExcludeArtifact tells the resolver to disregard a given maven artifact.
	// Can be repeated.
	JavaExcludeArtifact = "java_exclude_artifact"

	// JavaExtensionDirective represents the directive that controls whether
	// this Java extension is enabled or not. Sub-packages inherit this value.
	// Can be either "enabled" or "disabled". Defaults to "enabled".
	JavaExtensionDirective = "java_extension"

	// JavaMavenInstallFile represents the directive that controls where the
	// maven_install.json file is located.
	// Defaults to "maven_install.json".
	JavaMavenInstallFile = "java_maven_install_file"

	// MavenIndexFile represents the directive that controls where the index
	// file generated by `rules_jvm_external` is located.
	// Defaults to "maven_index.json"
	MavenIndexFile = "maven_index_file"

	// JavaModuleGranularityDirective represents the directive that controls whether
	// this Java module has a module granularity (Gradle) or a package
	// granularity (bazel).
	// Can be either "package" or "module". Defaults to "package".
	JavaModuleGranularityDirective = "java_module_granularity"

	// JavaTestFileSuffixes indicates within a test directory which files are test classes vs utility classes,
	// based on their basename.
	// It should be set up to match the value used for java_test_suite's test_suffixes attribute.
	// Accepted values are a comma-delimited list of strings.
	JavaTestFileSuffixes = "java_test_file_suffixes"

	// JavaTestMode allows user to choose from per file test or per directory test suite.
	JavaTestMode = "java_test_mode"

	// JavaGenerateProto tells the code generator whether to generate `java_proto_library` (and `java_library`)
	// rules when a `proto_library` rule is present.
	// Can be either "true" or "false". Defaults to "true".
	JavaGenerateProto = "java_generate_proto"

	// JavaMavenRepositoryName tells the code generator what the repository name that contains all maven dependencies is.
	// Defaults to "maven"
	JavaMavenRepositoryName = "java_maven_repository_name"

	// JavaAnnotationProcessorPlugin tells the code generator about specific java_plugin targets needed to process
	// specific annotations.
	JavaAnnotationProcessorPlugin = "java_annotation_processor_plugin"

	// JavaResolveToJavaExports tells the code generator to favour resolving dependencies to java_exports where possible.
	// If enabled, generated libraries will try to depend on java_exports targets that export a given package, instead of the underlying library.
	// This allows monorepos to closely match a traditional Gradle/Maven model where subprojects are published in jars.
	// Can be either "true" or "false". Defaults to "true".
	// Inherited by children packages, can only be set at the root of the repository.
	JavaResolveToJavaExports = "java_resolve_to_java_exports"

	// JavaSourcesetRoot explicitly marks a directory as the root of a sourceset.
	// This provides a clear override to the auto-detection algorithm.
	// Example: # gazelle:java_sourceset_root my/custom/src
	JavaSourcesetRoot = "java_sourceset_root"

	// JavaStripResourcesPrefix overrides the path-stripping behavior for resources.
	// This is a direct way to specify the resource_strip_prefix for all resources in a directory.
	// Example: # gazelle:java_strip_resources_prefix my/data/config
	JavaStripResourcesPrefix = "java_strip_resources_prefix"

	//JavaGenerateBinary tells the code generator to generate the `java_binary` rules
	// Can be either "true" or "false". Defaults to "true"
	JavaGenerateBinary = "java_generate_binary"

	// JvmKotlinEnabled tells the code generator whether to support `kt_jvm_library` rules for Kotlin sources.
	// Can be either "true" or "false". Defaults to "true".
	// This requires importing the `@rules_kotlin` repository into your workspace if there are any Kotlin sources in the repo.
	JvmKotlinEnabled = "jvm_kotlin_enabled"

	// Tells the code generator to generate `pkg_files` rules for the resources directories
	JavaGenerateResources = "java_generate_resources"

	// JavaSearch tells Gazelle where to look for Java packages during lazy indexing.
	// Format: # gazelle:java_search <directory> [package=<package_name>]
	// Examples:
	//   # gazelle:java_search src/main/java
	//   # gazelle:java_search third_party/example package=com.example
	// When package is specified, imports matching that package prefix will have
	// the package prefix stripped when computing the directory path.
	JavaSearch = "java_search"

	// JavaSearchExclude tells Gazelle to exclude a directory from source root discovery.
	// Format: # gazelle:java_search_exclude <directory>
	// This is useful when java_maven_layout discovers directories that should not be
	// included as source roots (e.g., build outputs, vendored code, or test fixtures).
	// The directory path should be relative to the workspace root.
	// Examples:
	//   # gazelle:java_search_exclude build/generated
	//   # gazelle:java_search_exclude third_party/vendored
	JavaSearchExclude = "java_search_exclude"

	// JavaMavenLayout enables automatic discovery of Maven/Gradle-style source roots.
	// Format: # gazelle:java_maven_layout [depth=<n>]
	// This will scan for directories matching the pattern */src/*/{java,kotlin}.
	// The depth parameter controls how many directory levels can appear before "src":
	//   - depth=0: matches src/main/java (no nesting)
	//   - depth=1: also matches moduleA/src/main/java (one level of nesting)
	//   - depth=2: also matches parent/child/src/main/java (two levels)
	// Default depth is 5.
	// Examples:
	//   # gazelle:java_maven_layout
	//   # gazelle:java_maven_layout depth=3
	JavaMavenLayout = "java_maven_layout"
)

// Configs is an extension of map[string]*Config. It provides finding methods
// on top of the mapping.
type Configs map[string]*Config

// NewChild creates a new child Config. It inherits desired values from the
// current Config and sets itself as the parent to the child.
func (c *Config) NewChild() *Config {
	clonedExcludedArtifacts := make(map[string]struct{})
	for key, value := range c.excludedArtifacts {
		clonedExcludedArtifacts[key] = value
	}
	annotationProcessorFullQualifiedClassToPluginClass := make(map[string]*sorted_set.SortedSet[types.ClassName])
	for key, value := range c.annotationProcessorFullQualifiedClassToPluginClass {
		annotationProcessorFullQualifiedClassToPluginClass[key] = value.Clone()
	}
	// Clone search paths slice
	clonedSearchPaths := make([]SearchPath, len(c.searchPaths))
	copy(clonedSearchPaths, c.searchPaths)
	// Clone search excludes slice
	clonedSearchExcludes := make([]string, len(c.searchExcludes))
	copy(clonedSearchExcludes, c.searchExcludes)
	return &Config{
		parent:                 c,
		extensionEnabled:       c.extensionEnabled,
		isModuleRoot:           false,
		generateProto:          true,
		generateBinary:         c.generateBinary,
		generateResources:      c.generateResources,
		resolveToJavaExports:   c.resolveToJavaExports,
		kotlinEnabled:          c.kotlinEnabled,
		mavenInstallFile:       c.mavenInstallFile,
		mavenIndexFile:         c.mavenIndexFile,
		moduleGranularity:      c.moduleGranularity,
		repoRoot:               c.repoRoot,
		testMode:               c.testMode,
		customTestFileSuffixes: c.customTestFileSuffixes,
		annotationToAttribute:  c.annotationToAttribute,
		annotationToWrapper:    c.annotationToWrapper,
		excludedArtifacts:      clonedExcludedArtifacts,
		mavenRepositoryName:    c.mavenRepositoryName,
		annotationProcessorFullQualifiedClassToPluginClass: annotationProcessorFullQualifiedClassToPluginClass,
		searchPaths:    clonedSearchPaths,
		searchExcludes: clonedSearchExcludes,
	}
}

// ParentForPackage returns the parent Config for the given Bazel package.
func (c *Configs) ParentForPackage(pkg string) *Config {
	dir := path.Dir(pkg)
	if dir == "." {
		dir = ""
	}
	parent := (map[string]*Config)(*c)[dir]
	return parent
}

// Config represents a config extension for a specific Bazel package.
type Config struct {
	parent *Config

	extensionEnabled                                   bool
	isModuleRoot                                       bool
	generateProto                                      bool
	generateBinary                                     bool
	generateResources                                  bool
	resolveToJavaExports                               *types.LateInit[bool]
	kotlinEnabled                                      bool
	mavenInstallFile                                   string
	mavenIndexFile                                     string
	moduleGranularity                                  string
	repoRoot                                           string
	testMode                                           string
	customTestFileSuffixes                             *[]string
	excludedArtifacts                                  map[string]struct{}
	annotationToAttribute                              map[string]map[string]bzl.Expr
	annotationToWrapper                                map[string]string
	mavenRepositoryName                                string
	annotationProcessorFullQualifiedClassToPluginClass map[string]*sorted_set.SortedSet[types.ClassName]
	sourcesetRoot                                      string
	stripResourcesPrefix                               string
	searchPaths                                        []SearchPath
	searchExcludes                                     []string
	mavenLayoutDiscovered                              bool
}

type LoadInfo struct {
	From   string
	Symbol string
}

// SearchPath represents a java_search directive for lazy indexing.
// It tells Gazelle where to look for Java packages.
type SearchPath struct {
	// Dir is the directory to search (relative to workspace root)
	Dir string
	// Package is the Java package prefix. When non-empty, imports matching
	// this prefix will have it stripped when computing the directory path.
	// For example, with Dir="third_party/example" and Package="com.example",
	// an import of "com.example.util" would look in "third_party/example/util".
	Package string
}

// parseSearchDirective parses a java_search directive value.
// Format: <directory> [package=<package_name>]
// Examples:
//
//	src/main/java
//	third_party/example package=com.example
func parseSearchDirective(value string) (SearchPath, error) {
	parts := strings.Fields(value)
	if len(parts) == 0 {
		return SearchPath{}, fmt.Errorf("expected at least a directory")
	}

	sp := SearchPath{
		Dir: parts[0],
	}

	for _, part := range parts[1:] {
		if strings.HasPrefix(part, "package=") {
			sp.Package = strings.TrimPrefix(part, "package=")
		} else {
			return SearchPath{}, fmt.Errorf("unknown option %q, expected package=<package_name>", part)
		}
	}

	return sp, nil
}

// parseMavenLayoutDirective parses a java_maven_layout directive value.
// Format: [depth=<n>]
// Examples:
//
//	(empty - uses default depth of 5)
//	depth=3
func parseMavenLayoutDirective(value string) (int, error) {
	parts := strings.Fields(value)

	depth := 5 // default
	for _, part := range parts {
		if strings.HasPrefix(part, "depth=") {
			depthStr := strings.TrimPrefix(part, "depth=")
			var err error
			depth, err = strconv.Atoi(depthStr)
			if err != nil {
				return 0, fmt.Errorf("invalid depth value %q: %v", depthStr, err)
			}
			if depth < 0 {
				return 0, fmt.Errorf("depth must be non-negative, got %d", depth)
			}
		} else {
			return 0, fmt.Errorf("unknown option %q, expected depth=<n>", part)
		}
	}

	return depth, nil
}

// New creates a new Config.
func New(repoRoot string) *Config {
	return &Config{
		extensionEnabled:       true,
		isModuleRoot:           false,
		generateProto:          true,
		generateBinary:         true,
		generateResources:      true,
		resolveToJavaExports:   types.NewLateInit[bool](true),
		kotlinEnabled:          true,
		mavenInstallFile:       "maven_install.json",
		mavenIndexFile:         "maven_index.json",
		moduleGranularity:      "package",
		repoRoot:               repoRoot,
		testMode:               "suite",
		customTestFileSuffixes: nil,
		excludedArtifacts:      make(map[string]struct{}),
		annotationToAttribute:  make(map[string]map[string]bzl.Expr),
		annotationToWrapper:    make(map[string]string),
		mavenRepositoryName:    "maven",
		annotationProcessorFullQualifiedClassToPluginClass: make(map[string]*sorted_set.SortedSet[types.ClassName]),
		sourcesetRoot:        "",
		stripResourcesPrefix: "",
	}
}

// ExtensionEnabled returns whether the extension is enabled or not.
func (c *Config) ExtensionEnabled() bool {
	return c.extensionEnabled
}

// SetExtensionEnabled sets whether the extension is enabled or not.
func (c *Config) SetExtensionEnabled(enabled bool) {
	c.extensionEnabled = enabled
}

func (c Config) IsModuleRoot() bool {
	return c.isModuleRoot
}

func (c *Config) GenerateProto() bool {
	return c.generateProto
}

func (c *Config) SetGenerateProto(generate bool) {
	c.generateProto = generate
}

func (c *Config) GenerateBinary() bool {
	return c.generateBinary
}

func (c *Config) SetGenerateBinary(generate bool) {
	c.generateBinary = generate
}

func (c *Config) GenerateResources() bool {
	return c.generateResources
}

func (c *Config) SetGenerateResources(enabled bool) {
	c.generateResources = enabled
}

func (c *Config) KotlinEnabled() bool {
	return c.kotlinEnabled
}

func (c *Config) SetKotlinEnabled(enabled bool) {
	c.kotlinEnabled = enabled
}

func (c *Config) MavenRepositoryName() string {
	return c.mavenRepositoryName
}

func (c *Config) SetMavenRepositoryName(name string) {
	c.mavenRepositoryName = name
}

func (c Config) MavenInstallFile() string {
	return filepath.Join(c.repoRoot, c.mavenInstallFile)
}

func (c *Config) SetMavenInstallFile(filename string) {
	c.mavenInstallFile = filename
}

func (c Config) MavenIndexFile() string {
	return filepath.Join(c.repoRoot, c.mavenIndexFile)
}

func (c *Config) SetMavenIndexFile(filename string) {
	c.mavenIndexFile = filename
}

func (c Config) ModuleGranularity() string {
	return c.moduleGranularity
}

func (c *Config) SetModuleGranularity(granularity string) error {
	if granularity != "module" && granularity != "package" {
		return fmt.Errorf("%s: possible values are module/package", granularity)
	}

	if granularity == "module" {
		if c.parent == nil || c.parent.moduleGranularity == "package" {
			c.isModuleRoot = true
		}
	}

	c.moduleGranularity = granularity

	return nil
}

func (c Config) TestMode() string {
	return c.testMode
}

func (c *Config) SetTestMode(mode string) error {
	if mode != "file" && mode != "suite" {
		return fmt.Errorf("%s: possible values are 'file' or 'suite'", mode)
	}

	c.testMode = mode
	return nil
}

func (c *Config) IsJavaTestFile(basename string) bool {
	// This variable is generated by a genrule //java/gazelle/javaconfig:generate_default_java_test_patterns_src.
	suffixes := defaultTestFileSuffixes
	if c.customTestFileSuffixes != nil {
		suffixes = *c.customTestFileSuffixes
	}
	for _, suffix := range suffixes {
		if strings.HasSuffix(basename, suffix) {
			return true
		}
	}
	return false
}

func (c *Config) SetJavaTestFileSuffixes(suffixesString string) error {
	suffixes := strings.Split(suffixesString, ",")
	if equalStringSlices(suffixes, defaultTestFileSuffixes) {
		c.customTestFileSuffixes = nil
	} else {
		c.customTestFileSuffixes = &suffixes
	}
	return nil
}

func (c *Config) GetCustomJavaTestFileSuffixes() *[]string {
	return c.customTestFileSuffixes
}

func (c Config) ExcludedArtifacts() map[string]struct{} {
	return c.excludedArtifacts
}

func (c *Config) AddExcludedArtifact(s string) error {
	c.excludedArtifacts[s] = struct{}{}
	return nil
}

func (c *Config) MapAnnotationToAttribute(annotation string, key string, value bzl.Expr) {
	if _, ok := c.annotationToAttribute[annotation]; !ok {
		c.annotationToAttribute[annotation] = make(map[string]bzl.Expr)
	}
	c.annotationToAttribute[annotation][key] = value
}

func (c *Config) AttributesForAnnotation(annotation string) (map[string]bzl.Expr, bool) {
	m, ok := c.annotationToAttribute[annotation]
	return m, ok
}

func (c *Config) MapAnnotationToWrapper(annotation string, wrapper string) {
	c.annotationToWrapper[annotation] = wrapper
}

func (c *Config) WrapperForAnnotation(annotation string) (string, bool) {
	s, ok := c.annotationToWrapper[annotation]
	return s, ok
}

func (c *Config) IsTestRule(ruleKind string) bool {
	if ruleKind == "java_junit5_test" || ruleKind == "java_test" || ruleKind == "java_test_suite" {
		return true
	}
	for _, wrapper := range c.annotationToWrapper {
		if ruleKind == wrapper {
			return true
		}
	}
	return false
}

func (c *Config) GetAnnotationProcessorPluginClasses(annotationClass types.ClassName) *sorted_set.SortedSet[types.ClassName] {
	return c.annotationProcessorFullQualifiedClassToPluginClass[annotationClass.FullyQualifiedClassName()]
}

func (c *Config) AddAnnotationProcessorPlugin(annotationClass types.ClassName, processorClass types.ClassName) {
	fullyQualifiedAnnotationClass := annotationClass.FullyQualifiedClassName()
	if _, ok := c.annotationProcessorFullQualifiedClassToPluginClass[fullyQualifiedAnnotationClass]; !ok {
		c.annotationProcessorFullQualifiedClassToPluginClass[fullyQualifiedAnnotationClass] = sorted_set.NewSortedSetFn[types.ClassName](nil, types.ClassNameLess)
	}
	c.annotationProcessorFullQualifiedClassToPluginClass[fullyQualifiedAnnotationClass].Add(processorClass)
}

func (c *Config) ResolveToJavaExports() bool {
	return c.resolveToJavaExports.Value()
}

func (c *Config) CanSetResolveToJavaExports() bool {
	return !c.resolveToJavaExports.IsInitialized()
}

func (c *Config) SetResolveToJavaExports(resolve bool) {
	c.resolveToJavaExports.Initialize(resolve)
}

func (c *Config) SourcesetRoot() string {
	return c.sourcesetRoot
}

func (c *Config) SetSourcesetRoot(root string) {
	c.sourcesetRoot = root
}

func (c *Config) StripResourcesPrefix() string {
	return c.stripResourcesPrefix
}

func (c *Config) SetStripResourcesPrefix(prefix string) {
	c.stripResourcesPrefix = prefix
}

func equalStringSlices(l, r []string) bool {
	if len(l) != len(r) {
		return false
	}
	for i := range l {
		if l[i] != r[i] {
			return false
		}
	}
	return true
}

// AddSearchPath parses and adds a search path for lazy indexing.
// Format: <directory> [package=<package_name>]
func (c *Config) AddSearchPath(value string) error {
	sp, err := parseSearchDirective(value)
	if err != nil {
		return err
	}
	c.searchPaths = append(c.searchPaths, sp)
	return nil
}

// addSearchPathInternal adds a search path directly without parsing.
func (c *Config) addSearchPathInternal(sp SearchPath) {
	c.searchPaths = append(c.searchPaths, sp)
}

// SearchPaths returns the configured search paths.
func (c *Config) SearchPaths() []SearchPath {
	return c.searchPaths
}

// AddSearchExclude adds a directory to exclude from source root discovery.
func (c *Config) AddSearchExclude(dir string) {
	c.searchExcludes = append(c.searchExcludes, dir)
}

// SearchExcludes returns the configured search excludes.
func (c *Config) SearchExcludes() []string {
	return c.searchExcludes
}

// IsSearchExcluded returns true if the given directory should be excluded
// from source root discovery. The directory is excluded if it matches or
// is a subdirectory of any excluded path.
func (c *Config) IsSearchExcluded(dir string) bool {
	for _, exclude := range c.searchExcludes {
		if dir == exclude || strings.HasPrefix(dir, exclude+"/") {
			return true
		}
	}
	return false
}

// PathsForPackage returns the directories that should be indexed
// for the given Java package name. This is used for lazy indexing.
func (c *Config) PathsForPackage(pkg string) []string {
	if len(c.searchPaths) == 0 {
		return nil
	}

	// Convert package name to path (com.example.util -> com/example/util)
	pkgPath := strings.ReplaceAll(pkg, ".", "/")

	var paths []string
	for _, sp := range c.searchPaths {
		if sp.Package == "" {
			// No package prefix specified - use full package path
			paths = append(paths, path.Join(sp.Dir, pkgPath))
		} else {
			// Check if the import matches the package prefix
			if pkg == sp.Package {
				// Exact match - the directory itself
				paths = append(paths, sp.Dir)
			} else if strings.HasPrefix(pkg, sp.Package+".") {
				// Prefix match - strip prefix and append remainder
				remainder := strings.TrimPrefix(pkg, sp.Package+".")
				remainderPath := strings.ReplaceAll(remainder, ".", "/")
				paths = append(paths, path.Join(sp.Dir, remainderPath))
			}
			// If no match, this search path doesn't apply to this package
		}
	}

	return paths
}

// PackageFromPath attempts to derive a Java package name from a file path
// using the configured search paths. Returns empty string if the path
// doesn't match any configured source root.
//
// Example: with search path "src/main/java", the path
// "src/main/java/com/example/Foo.java" returns "com.example"
func (c *Config) PackageFromPath(filePath string) string {
	if len(c.searchPaths) == 0 {
		return ""
	}

	// Normalize to forward slashes
	normalized := strings.ReplaceAll(filePath, "\\", "/")

	for _, sp := range c.searchPaths {
		// Check if the path starts with this search path directory
		prefix := sp.Dir + "/"
		if !strings.HasPrefix(normalized, prefix) {
			continue
		}

		// Get the path after the source root
		afterRoot := strings.TrimPrefix(normalized, prefix)

		// Remove the filename to get just the directory path
		lastSlash := strings.LastIndex(afterRoot, "/")
		if lastSlash == -1 {
			// File is directly in the source root - no package
			if sp.Package != "" {
				return sp.Package
			}
			continue
		}

		pkgPath := afterRoot[:lastSlash]
		// Convert path separators to dots
		pkgName := strings.ReplaceAll(pkgPath, "/", ".")

		// If there's a package prefix, prepend it
		if sp.Package != "" {
			return sp.Package + "." + pkgName
		}
		return pkgName
	}

	return ""
}

// MavenLayoutDiscovered returns whether maven layout discovery has been run.
func (c *Config) MavenLayoutDiscovered() bool {
	return c.mavenLayoutDiscovered
}

// DiscoverMavenLayout scans the repository for Maven/Gradle-style source roots
// matching the pattern */src/*/{java,kotlin}.
// Format: [depth=<n>]
// The depth parameter controls how many directory levels can appear before "src":
//   - depth=0: matches src/main/java (no nesting)
//   - depth=1: also matches moduleA/src/main/java (one level of nesting)
//   - depth=2: also matches parent/child/src/main/java (two levels)
//
// It adds discovered directories as search paths.
// Returns the list of discovered source roots and any parse error.
func (c *Config) DiscoverMavenLayout(value string) ([]string, error) {
	depth, err := parseMavenLayoutDirective(value)
	if err != nil {
		return nil, err
	}
	return c.discoverMavenLayoutWithDepth(depth), nil
}

// discoverMavenLayoutWithDepth is the internal implementation that takes a parsed depth.
func (c *Config) discoverMavenLayoutWithDepth(depth int) []string {
	if c.mavenLayoutDiscovered {
		return nil
	}
	c.mavenLayoutDiscovered = true

	var discovered []string

	// We need to traverse deep enough to find src/<sourceset>/{java,kotlin}
	// at any nesting level up to 'depth' directories before src.
	// So total traversal depth = depth (before src) + 3 (src/<sourceset>/{java,kotlin})
	maxTraversalDepth := depth + 3

	// Walk the directory tree looking for directories matching the pattern
	err := walkDirWithDepth(c.repoRoot, maxTraversalDepth, func(dirPath string, d fs.DirEntry) error {
		if !d.IsDir() {
			return nil
		}

		name := d.Name()
		if name != "java" && name != "kotlin" {
			return nil
		}

		// Check if parent matches the pattern: .../src/<sourceset>/{java,kotlin}
		rel, err := filepath.Rel(c.repoRoot, dirPath)
		if err != nil {
			return nil
		}

		// Split path and check for src/<something>/{java,kotlin} pattern
		parts := strings.Split(filepath.ToSlash(rel), "/")
		if len(parts) < 3 {
			return nil
		}

		// Check if the pattern matches: .../src/<sourceset>/{java,kotlin}
		// The last element is java or kotlin (already checked above)
		// The second-to-last can be anything (main, test, integrationTest, etc.)
		// The third-to-last should be "src"
		if parts[len(parts)-3] != "src" {
			return nil
		}

		// Count directories before "src" - this is the nesting level
		// parts = [moduleA, src, main, java] -> nestingLevel = 1
		// parts = [src, main, java] -> nestingLevel = 0
		nestingLevel := len(parts) - 3
		if nestingLevel > depth {
			return nil
		}

		// Normalize to forward slashes
		normalizedRel := filepath.ToSlash(rel)

		// Check if this path is excluded
		if c.IsSearchExcluded(normalizedRel) {
			return nil
		}

		// Found a match!
		discovered = append(discovered, normalizedRel)
		c.addSearchPathInternal(SearchPath{Dir: normalizedRel})

		return nil
	})

	if err != nil {
		// Log error but don't fail - best effort discovery
		return discovered
	}

	return discovered
}

// walkDirWithDepth walks a directory tree up to a maximum depth.
// depth=0 means only the root directory, depth=1 means root and immediate children, etc.
func walkDirWithDepth(root string, maxDepth int, fn func(path string, d fs.DirEntry) error) error {
	return walkDirWithDepthRecursive(root, 0, maxDepth, fn)
}

func walkDirWithDepthRecursive(dir string, currentDepth, maxDepth int, fn func(path string, d fs.DirEntry) error) error {
	if currentDepth > maxDepth {
		return nil
	}

	entries, err := os.ReadDir(dir)
	if err != nil {
		return nil // Skip directories we can't read
	}

	for _, entry := range entries {
		// Skip symlinks
		if entry.Type()&fs.ModeSymlink != 0 {
			continue
		}

		entryPath := filepath.Join(dir, entry.Name())

		if err := fn(entryPath, entry); err != nil {
			if err == fs.SkipDir {
				continue
			}
			return err
		}

		if entry.IsDir() {
			if err := walkDirWithDepthRecursive(entryPath, currentDepth+1, maxDepth, fn); err != nil {
				return err
			}
		}
	}

	return nil
}
