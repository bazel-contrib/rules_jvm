package maven

import (
	"fmt"
	"os"
	"sort"

	"github.com/bazel-contrib/rules_jvm/java/gazelle/private/bazel"
	"github.com/bazel-contrib/rules_jvm/java/gazelle/private/maven/multiset"
	"github.com/bazel-contrib/rules_jvm/java/gazelle/private/types"
	"github.com/bazelbuild/bazel-gazelle/label"
	"github.com/rs/zerolog"
)

// NoExternalImportsError represents the error when no external imports are found.
type NoExternalImportsError struct {
	PackageName string
}

func (e *NoExternalImportsError) Error() string {
	return fmt.Sprintf("no external imports found for %s", e.PackageName)
}

// MultipleExternalImportsError represents the error when multiple possible external imports are found.
type MultipleExternalImportsError struct {
	PackageName      string
	PossiblePackages []string
}

func (e *MultipleExternalImportsError) Error() string {
	return fmt.Sprintf("multiple external imports found for %s; %v", e.PackageName, e.PossiblePackages)
}

type Resolver interface {
	Resolve(pkg types.PackageName, excludedArtifacts map[string]struct{}, mavenRepositoryName string) (label.Label, error)
	ResolveClass(className types.ClassName, excludedArtifacts map[string]struct{}, mavenRepositoryName string) (label.Label, error)
}

// resolver finds Maven provided packages by reading the maven_install.json
// file from rules_jvm_external.
type resolver struct {
	data       *multiset.StringMultiSet
	classIndex map[string]string
	logger     zerolog.Logger
}

// ResolverOption configures a resolver.
type ResolverOption func(*resolverConfig)

type resolverConfig struct {
	installFile string
	indexFile   string
	logger      zerolog.Logger
}

// WithInstallFile sets the path to the maven_install.json lock file.
func WithInstallFile(path string) ResolverOption {
	return func(c *resolverConfig) {
		c.installFile = path
	}
}

// WithIndexFile sets the path to the index file generated by rules_jvm_external.
func WithIndexFile(path string) ResolverOption {
	return func(c *resolverConfig) {
		c.indexFile = path
	}
}

// WithLogger sets the logger for the resolver.
func WithLogger(logger zerolog.Logger) ResolverOption {
	return func(c *resolverConfig) {
		c.logger = logger
	}
}

func NewResolver(opts ...ResolverOption) (Resolver, error) {
	cfg := &resolverConfig{
		logger: zerolog.Nop(),
	}
	for _, opt := range opts {
		opt(cfg)
	}

	r := resolver{
		data:       multiset.NewStringMultiSet(),
		classIndex: make(map[string]string),
		logger:     cfg.logger.With().Str("_c", "maven-resolver").Logger(),
	}

	var c lockFile
	var lockFileErr error
	if cfg.installFile != "" {
		c, lockFileErr = loadConfiguration(cfg.installFile)
	}

	var index *IndexFile
	var indexFileErr error
	if cfg.indexFile != "" {
		index, indexFileErr = loadIndex(cfg.indexFile)
		if indexFileErr != nil && !os.IsNotExist(indexFileErr) {
			r.logger.Warn().Err(indexFileErr).Msg("failed to load index file")
		}
	}

	// Warn and return early if neither lock file nor index file is available
	if lockFileErr != nil || c == nil {
		if index == nil {
			if lockFileErr != nil {
				r.logger.Warn().Err(lockFileErr).Msg("not loading maven dependencies")
			} else {
				r.logger.Warn().Msg("no maven install file or index file configured")
			}
			return &r, nil
		}
		// We have an index but no lock file - we can't proceed without the lock file
		// since we need it for dependency coordinates
		r.logger.Warn().Msg("index file available but lock file required for dependency coordinates")
		return &r, nil
	}

	dependencies := c.ListDependencies()

	r.logger.Debug().Int("count", len(dependencies)).Msg("Dependency count")

	for _, depName := range dependencies {
		coords, err := ParseCoordinate(c.GetDependencyCoordinates(depName))
		if err != nil {
			return nil, fmt.Errorf("failed to parse coordinate %v: %w", coords, err)
		}
		for _, pkg := range c.ListDependencyPackages(depName) {
			r.data.Add(pkg, coords.ArtifactString())
		}
		for _, class := range c.ListDependencyClasses(depName) {
			r.classIndex[class] = coords.ArtifactString()
		}
		if index != nil {
			// Use classes section for split package class-level resolution
			if pkgMap, ok := index.Classes[depName]; ok {
				for pkg, classes := range pkgMap {
					// Seed package→artifact mapping so split packages are detected
					// as "multiple providers" rather than "not found"
					if pkg != "" {
						r.data.Add(pkg, coords.ArtifactString())
					}
					for _, cls := range classes {
						fqcn := cls
						if pkg != "" {
							fqcn = pkg + "." + cls
						}
						r.classIndex[fqcn] = coords.ArtifactString()
					}
				}
			}
			// Use packages section for simple package→artifact lookup
			if packages, ok := index.Packages[depName]; ok {
				for _, pkg := range packages {
					r.data.Add(pkg, coords.ArtifactString())
				}
			}
		}
	}

	return &r, nil
}

func (r *resolver) Resolve(pkg types.PackageName, excludedArtifacts map[string]struct{}, mavenRepositoryName string) (label.Label, error) {
	v, found := r.data.Get(pkg.Name)
	if !found {
		return label.NoLabel, &NoExternalImportsError{PackageName: pkg.Name}
	}

	var filtered []string
	for k := range v {
		if _, excluded := excludedArtifacts[LabelFromArtifact(mavenRepositoryName, k).String()]; excluded {
			continue
		}
		filtered = append(filtered, LabelFromArtifact(mavenRepositoryName, k).String())
	}
	sort.Strings(filtered)

	switch len(filtered) {
	case 0:
		return label.NoLabel, &NoExternalImportsError{PackageName: pkg.Name}

	case 1:
		var ret string
		for _, r := range filtered {
			ret = r
			break
		}
		return label.Parse(ret)

	default:
		return label.NoLabel, &MultipleExternalImportsError{
			PackageName:      pkg.Name,
			PossiblePackages: filtered,
		}
	}
}

func (r *resolver) ResolveClass(className types.ClassName, excludedArtifacts map[string]struct{}, mavenRepositoryName string) (label.Label, error) {
	artifact, found := r.classIndex[className.FullyQualifiedClassName()]
	if !found {
		return label.NoLabel, nil
	}

	if _, excluded := excludedArtifacts[LabelFromArtifact(mavenRepositoryName, artifact).String()]; excluded {
		return label.NoLabel, nil
	}

	return LabelFromArtifact(mavenRepositoryName, artifact), nil
}

func LabelFromArtifact(mavenRepositoryName string, artifact string) label.Label {
	return label.New(mavenRepositoryName, "", bazel.CleanupLabel(artifact))
}
